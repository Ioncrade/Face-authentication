# -*- coding: utf-8 -*-
"""BatAlgorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rhCGW8hNlQcWO0TO8a7YbWs9nV8u6EBZ
"""

# ================= Bat Algorithm Class ====================
class BatAlgorithm:
    def __init__(self, feature_length, population_size=20, max_iterations=50, loudness=0.5, pulse_rate=0.5):
        self.population_size = population_size
        self.max_iterations = max_iterations
        self.A = loudness
        self.r = pulse_rate
        self.Qmin = 0  # frequency min
        self.Qmax = 2  # frequency max
        self.feature_length = feature_length

    def _fitness(self, candidate, target):
        return cosine_similarity([candidate], [target])[0][0]  # maximize similarity

    def optimize(self, target_vector, candidates):
        n = self.population_size
        d = self.feature_length

        # Initialize bats
        positions = [np.copy(random.choice(candidates)) for _ in range(n)]
        velocities = [np.zeros(d) for _ in range(n)]
        frequencies = np.zeros(n)
        fitness = [self._fitness(pos, target_vector) for pos in positions]
        best_idx = np.argmax(fitness)
        best_solution = positions[best_idx]
        best_fitness = fitness[best_idx]

        for t in range(self.max_iterations):
            for i in range(n):
                frequencies[i] = self.Qmin + (self.Qmax - self.Qmin) * random.random()
                velocities[i] = velocities[i] + (positions[i] - best_solution) * frequencies[i]
                new_solution = positions[i] + velocities[i]

                new_solution = np.clip(new_solution, 0, 1)  # bounds handling

                if random.random() > self.r:
                    epsilon = np.random.randn(d)
                    new_solution = best_solution + epsilon * self.A

                new_fitness = self._fitness(new_solution, target_vector)

                if new_fitness > fitness[i] and random.random() < self.A:
                    positions[i] = new_solution
                    fitness[i] = new_fitness

                    if new_fitness > best_fitness:
                        best_solution = new_solution
                        best_fitness = new_fitness

        return best_solution, best_fitness


# ================= User Authentication using Bat Algorithm ====================
def authenticate_user_with_bat(user_input_face, user_input_iris, db):
    all_users = db.list_all_users()
    if not all_users:
        logger.warning("No users in the database.")
        return None

    best_match = None
    best_score = -1

    input_face = user_input_face / np.linalg.norm(user_input_face)
    input_iris = user_input_iris / np.linalg.norm(user_input_iris)

    face_candidates = []
    iris_candidates = []
    user_ids = []

    for uid in all_users:
        user_template = db.get_user_template(uid)
        face_feat = user_template['face_features']
        iris_feat = user_template['iris_features']

        face_feat = face_feat / np.linalg.norm(face_feat)
        iris_feat = iris_feat / np.linalg.norm(iris_feat)

        face_candidates.append(face_feat)
        iris_candidates.append(iris_feat)
        user_ids.append(uid)

    face_ba = BatAlgorithm(feature_length=len(input_face))
    iris_ba = BatAlgorithm(feature_length=len(input_iris))

    _, face_best_score = face_ba.optimize(input_face, face_candidates)
    _, iris_best_score = iris_ba.optimize(input_iris, iris_candidates)

    combined_scores = []
    for i in range(len(user_ids)):
        face_score = cosine_similarity([face_candidates[i]], [input_face])[0][0]
        iris_score = cosine_similarity([iris_candidates[i]], [input_iris])[0][0]
        combined_scores.append((user_ids[i], 0.5 * face_score + 0.5 * iris_score))

    best_match = max(combined_scores, key=lambda x: x[1])

    logger.info(f"User authenticated using Bat Algorithm: {best_match[0]} with score: {best_match[1]}")
    return best_match[0] if best_match[1] > 0.8 else None  # threshold